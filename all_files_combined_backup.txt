

==== config/googleApiConfig.js ====

// config/googleApiConfig.js

require('dotenv').config();

module.exports = {
    CALENDARS: {
        "Bay 1 (Bar)": "a6234ae4e57933edb48a264fff4c5d3d3653f7bedce12cfd9a707c6c0ff092e4@group.calendar.google.com",
        "Bay 2": "3a700346dd902abd4aa448ee63e184a62f05d38bb39cb19a8fc27116c6df3233@group.calendar.google.com",
        "Bay 3 (Entrance)": "092757d971c313c2986b43f4c8552382a7e273b183722a44a1c4e1a396568ca3@group.calendar.google.com"
    },

    googleAuth: {
        credentials: JSON.parse(Buffer.from(process.env.SERVICE_ACCOUNT_KEY_BASE64, 'base64').toString('utf-8')),
        scopes: [
            'https://www.googleapis.com/auth/calendar',
            'https://www.googleapis.com/auth/spreadsheets'
        ]
    },

    SPREADSHEET_ID: process.env.SPREADSHEET_ID,

    LINE_NOTIFY_TOKEN: process.env.LINE_NOTIFY_TOKEN
};




==== config/redisConfig.js ====

const redis = require('redis');
const logger = require('../utils/logger'); // Corrected path


// Create and configure Redis client
const client = redis.createClient({
    url: `redis://${process.env.REDIS_HOST || '172.18.56.192'}:${process.env.REDIS_PORT || 6379}`,
});

// Handle connection events
client.on('error', (err) => {
    logger.error('Redis Client Error', err);
});

client.on('connect', () => {
    logger.info('Connected to Redis');
});

// Connect the client
(async () => {
    try {
        await client.connect();
        logger.info('Redis client connected and ready to use');
    } catch (err) {
        logger.error('Error connecting to Redis:', err);
    }
})();

module.exports = client;




==== controllers/bookingController.js ====

// controllers/bookingController.js

const redisClient = require('../config/redisConfig');
const { findAvailableSlotsFromGoogle } = require('../utils/helpers');

/**
 * Get available slots for a specific date, first checking the Redis cache.
 */
exports.getAvailableSlots = async (dateStr) => {
    const cacheKey = `available_slots_${dateStr}`; // Ensured consistent cache key

    try {
        // Check Redis cache for available slots
        const cachedSlots = await redisClient.get(cacheKey);
        if (cachedSlots) {
            console.log(`Serving slots from Redis cache for ${dateStr}`);
            return JSON.parse(cachedSlots); // Return the cached slots
        }

        // If not in cache, calculate available slots from Google Calendar
        const slots = await findAvailableSlotsFromGoogle(dateStr);

        // Store the available slots in Redis for 10 minutes (600 seconds)
        await redisClient.setEx(cacheKey, 600, JSON.stringify(slots));

        return slots;
    } catch (error) {
        console.error('Error accessing Redis:', error);
        throw error;
    }
};




==== controllers/customerController.js ====

// controllers/customerController.js

// controllers/customerController.js

const { getCustomerData, saveCustomerData } = require('../utils/helpers');

/**
 * Get customer data from Google Sheets.
 */
exports.getCustomerDataById = async (userId) => {
    const customerData = await getCustomerData(userId);
    // Do not throw an error if customer data is not found
    // Return null instead
    return customerData;
};

/**
 * Save or update customer data in Google Sheets.
 */
exports.saveOrUpdateCustomerData = async (customerData) => {
    // Expecting customerData to include userId, name, email, phoneNumber
    await saveCustomerData(customerData);
};




==== public/css/styles.css ====

/* public/css/styles.css */

/* Define CSS Variables for Colors */
:root {
    --primary-color: #005a32; /* Dark Green */
    --neutral-color: #000000; /* Black */
    --accent-color: #ffffff; /* White */
    --background-color: #f0f0f0; /* Light Gray */
    --modal-header-color: #005a32; /* Primary Color for Modal Header */
    --hover-animation: scale(1.05); /* Animation for hover */
    --neutral-button-color: #6c757d; /* Neutral Gray for Buttons */
    --confirm-button-color: #005a32; /* Dark Green for Confirm Booking Button */
    --disabled-button-color: #6c757d; /* Neutral Gray for Disabled Buttons */
}

/* General Styles */
body {
    padding-top: 70px;
    background-color: var(--background-color);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 1rem;
    color: var(--neutral-color);
}

/* Navbar Customization */
.navbar {
    background-color: var(--primary-color) !important;
    padding: 15px 10px;
}

.navbar-brand {
    color: var(--accent-color) !important;
    font-size: 1.5rem;
    font-weight: 700;
}

/* Button Styles */
.btn-primary {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
    color: var(--accent-color);
    transition: transform 0.3s;
}

.btn-primary:hover,
.btn-primary:focus {
    transform: var(--hover-animation); /* Subtle scale animation */
    background-color: var(--primary-color); /* Maintain original color */
    border-color: var(--primary-color);
    color: var(--accent-color);
}

.btn-secondary {
    background-color: var(--neutral-button-color);
    border-color: var(--neutral-button-color);
    color: var(--accent-color);
    transition: transform 0.3s;
}

.btn-secondary:hover,
.btn-secondary:focus {
    transform: var(--hover-animation);
    background-color: #5a6268; /* Darker gray on hover */
    border-color: #545b62;
    color: var(--accent-color);
}

/* Confirm Booking Button */
.btn-primary#submit-booking-button:disabled {
    background-color: var(--disabled-button-color);
    border-color: var(--disabled-button-color);
    cursor: not-allowed;
    opacity: 0.65;
}

/* Slot Card Styling */
.slot-card {
    cursor: pointer;
    transition: transform 0.3s, box-shadow 0.3s;
    border: none;
    border-radius: 0.5rem;
    margin-bottom: 20px;
    background-color: var(--accent-color);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    padding: 15px;
    height: 100%;
    color: var(--neutral-color);
}

.slot-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
}

.slot-card .book-now-button {
    background-color: var(--primary-color); /* Dark Green */
    color: var(--accent-color);
    border: none;
    width: 100%;
    transition: transform 0.3s, background-color 0.3s, border-color 0.3s;
}

.slot-card .book-now-button:hover,
.slot-card .book-now-button:focus {
    transform: var(--hover-animation);
    background-color: var(--primary-color); /* Maintain original color */
    color: var(--accent-color);
}

/* Modal Customization */
.modal-header {
    background-color: var(--modal-header-color);
    color: var(--accent-color);
}

/* Make the X button more prominent */
.modal-header .btn-close-white {
    filter: brightness(0) invert(1); /* Makes it white */
}

/* Disable the X button when disabled class is added */
.modal-header .btn-close.disabled {
    pointer-events: none;
    opacity: 0.5;
}

/* Modal Footer Buttons when disabled */
.modal-footer .btn-secondary:disabled,
.modal-footer .btn-primary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Confirmation Section */
#confirmation-section {
    background-color: var(--accent-color);
    border: 1px solid var(--primary-color);
    padding: 20px;
    border-radius: 0.5rem;
}

#confirmation-section h3 {
    color: var(--neutral-color);
}

#confirmation-section p {
    color: var(--neutral-color);
}

/* Hidden Class to Hide Elements */
.hidden {
    display: none;
}

/* Spinner Overlay in Modal */
.modal-spinner-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1051; /* Higher than modal content */
}

.modal-spinner-overlay.hidden {
    display: none;
}

/* Number of People Buttons */
.num-people-button {
    min-width: 40px;
    margin-right: 5px;
    transition: background-color 0.3s, color 0.3s, border-color 0.3s;
}

.num-people-button.active {
    background-color: var(--primary-color);
    color: var(--accent-color);
    border-color: var(--primary-color);
}

.num-people-button.red-border {
    border-color: #dc3545; /* Red border when not selected */
}

.num-people-button.green-border {
    border-color: #198754; /* Green border when selected */
}

/* Error Messages */
.text-danger {
    font-size: 0.875rem;
}

/* Input Validation Styles */
input:invalid,
select:invalid {
    border-color: #dc3545;
}

input:valid,
select:valid {
    border-color: #198754;
}




==== public/js/main.js ====

// public/js/main.js

'use strict';

// Initialize Luxon for date handling
const DateTime = luxon.DateTime;

// Handle Google Credential Response
function handleCredentialResponse(response) {
    const data = parseJwt(response.credential);

    fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token: response.credential }),
    })
    .then(res => res.json())
    .then(data => {
        if (data.success) {
            // Store user data
            localStorage.setItem('userId', data.userId);
            localStorage.setItem('email', data.email);
            localStorage.setItem('name', data.name);
            localStorage.setItem('phoneNumber', data.phoneNumber || '');

            // Hide login section and show booking section
            document.getElementById('login-section').classList.add('hidden');
            document.getElementById('booking-section').classList.remove('hidden');
            document.getElementById('booking-section').classList.add('visible');

            // Show logout button
            document.getElementById('logout-button').style.display = 'block';
            initializeBooking();
        } else {
            alert('Login failed. Please try again.');
        }
    })
    .catch(err => {
        console.error('Error during login:', err);
        alert('An error occurred. Please try again.');
    });
}

// Utility function to parse JWT token
function parseJwt(token) {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));

    return JSON.parse(jsonPayload);
}

// Initialize the booking section
function initializeBooking() {
    const bookingDateInput = document.getElementById('booking-date');
    const selectedDateSpan = document.getElementById('selected-date');
    const loadingSpinner = document.getElementById('loading-spinner');
    const availableSlotsDiv = document.getElementById('available-slots');

    // Set default date to today
    const today = DateTime.now().toISODate();
    bookingDateInput.value = today;
    selectedDateSpan.textContent = today;

    // Fetch available slots for today
    fetchAvailableSlots(today);

    // Event listener for date change
    bookingDateInput.addEventListener('change', (e) => {
        const selectedDate = e.target.value;
        selectedDateSpan.textContent = selectedDate;
        fetchAvailableSlots(selectedDate);
    });

    // Add event listener for phone number input
    const phoneNumberInput = document.getElementById('phone-number');
    phoneNumberInput.addEventListener('input', validateForm);
}

// Fetch available slots from backend
function fetchAvailableSlots(date) {
    const availableSlotsDiv = document.getElementById('available-slots');
    const loadingSpinner = document.getElementById('loading-spinner');

    // Show loading spinner
    loadingSpinner.style.display = 'block';
    availableSlotsDiv.innerHTML = '';

    fetch(`/api/available-slots?date=${date}`)
        .then(res => res.json())
        .then(data => {
            loadingSpinner.style.display = 'none';
            if (data.success) {
                renderAvailableSlots(data.availableSlots);
            } else {
                availableSlotsDiv.innerHTML = `<p class="text-danger">${data.message}</p>`;
            }
        })
        .catch(err => {
            loadingSpinner.style.display = 'none';
            availableSlotsDiv.innerHTML = `<p class="text-danger">Failed to load available slots. Please try again.</p>`;
        });
}

// Render available slots on the page
function renderAvailableSlots(slots) {
    const availableSlotsDiv = document.getElementById('available-slots');
    availableSlotsDiv.innerHTML = '';

    if (slots.length === 0) {
        availableSlotsDiv.innerHTML = `<p class="text-warning">No available slots for the selected date.</p>`;
        return;
    }

    slots.forEach(slot => {
        const slotCol = document.createElement('div');
        slotCol.className = 'col-md-4 col-sm-6 mb-4';

        const slotCard = document.createElement('div');
        slotCard.className = 'card slot-card h-100';

        slotCard.innerHTML = `
            <div class="card-body d-flex flex-column">
                <h5 class="card-title fw-bold">
                    <i class="fas fa-clock me-2"></i>${slot.startTime}
                </h5>
                <p class="card-text">
                    Available for up to ${slot.maxDuration} hour(s)
                </p>
                <div class="mt-auto">
                    <button class="btn btn-primary book-now-button">Book Now</button>
                </div>
            </div>
        `;

        const bookNowButton = slotCard.querySelector('.book-now-button');
        bookNowButton.addEventListener('click', () => openBookingModal(slot.startTime, slot.maxDuration));

        slotCol.appendChild(slotCard);
        availableSlotsDiv.appendChild(slotCol);
    });

    // Initialize tooltips after slots are rendered
    initializeTooltips();
}

// Open the booking modal
function openBookingModal(startTime, maxDuration) {
    const slotModalElement = document.getElementById('slotModal');
    if (!window.bootstrap || !window.bootstrap.Modal) {
        console.error('Bootstrap Modal is not available.');
        alert('An error occurred while opening the booking modal. Please try again.');
        return;
    }

    const slotModal = new window.bootstrap.Modal(slotModalElement, {
        backdrop: 'static',
        keyboard: false
    });
    document.getElementById('selected-start-time').textContent = startTime;

    const durationSelect = document.getElementById('duration-select');
    durationSelect.innerHTML = '';
    for (let i = 1; i <= maxDuration; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${i} hour(s)`;
        durationSelect.appendChild(option);
    }

    durationSelect.removeEventListener('change', updateEndTime);
    durationSelect.addEventListener('change', updateEndTime);

    updateEndTime();
    prefillPhoneNumber();
    slotModal.show();

    // Reset number of people selection
    resetNumberOfPeopleSelection();
    validateForm();
}

// Update the end time display in the booking modal
function updateEndTime() {
    const startTime = document.getElementById('selected-start-time').textContent;
    const duration = parseInt(document.getElementById('duration-select').value);
    const [hour, minute] = startTime.split(':').map(Number);
    const endTime = DateTime.fromObject({ hour, minute }).plus({ hours: duration }).toFormat('HH:mm');
    document.getElementById('end-time-display').textContent = endTime;
    validateForm();
}

// Prefill the phone number from user data if available
function prefillPhoneNumber() {
    const phoneNumberInput = document.getElementById('phone-number');
    const prefilledIndicator = document.getElementById('phone-prefilled-indicator');
    const userPhone = localStorage.getItem('phoneNumber');

    if (userPhone) {
        phoneNumberInput.value = userPhone;
        prefilledIndicator.style.display = 'block';
        phoneNumberInput.classList.add('prefilled');
    } else {
        prefilledIndicator.style.display = 'none';
        phoneNumberInput.classList.remove('prefilled');
    }
    validateForm();
}

// Reset number of people selection
function resetNumberOfPeopleSelection() {
    const buttons = document.querySelectorAll('.num-people-button');
    buttons.forEach(button => button.classList.remove('active'));
    document.getElementById('number-of-people').value = '';
    // Remove any border classes
    buttons.forEach(button => {
        button.classList.remove('red-border', 'green-border');
    });
    validateForm();
}

// Handle booking submission
document.getElementById('submit-booking-button').addEventListener('click', () => {
    const userId = localStorage.getItem('userId');
    const userName = localStorage.getItem('name'); // Fetching the user's name
    const email = localStorage.getItem('email'); // Fetching the user's email
    const phoneNumber = document.getElementById('phone-number').value;
    const numberOfPeople = parseInt(document.getElementById('number-of-people').value);
    const date = document.getElementById('booking-date').value;
    const startTime = document.getElementById('selected-start-time').textContent;
    const duration = parseInt(document.getElementById('duration-select').value);
    const confirmButton = document.getElementById('submit-booking-button');
    const originalButtonText = confirmButton.innerHTML;

    if (!phoneNumber || isNaN(numberOfPeople) || numberOfPeople < 1) {
        alert('Please provide valid booking details.');
        return;
    }

    // Disable the confirm button and show a spinner
    confirmButton.disabled = true;
    confirmButton.innerHTML = `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Confirming...`;

    // Disable 'Back' and 'X' buttons
    const slotModalElement = document.getElementById('slotModal');
    const backButton = slotModalElement.querySelector('.btn-secondary');
    const closeButton = slotModalElement.querySelector('.btn-close');
    const spinnerOverlay = slotModalElement.querySelector('.modal-spinner-overlay');

    if (backButton) {
        backButton.disabled = true;
    }
    if (closeButton) {
        closeButton.classList.add('disabled');
    }
    if (spinnerOverlay) {
        spinnerOverlay.classList.remove('hidden');
    }

    fetch('/api/book-slot', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            userId,
            userName, // Include the user's name in the booking data
            email, // Include the user's email
            phoneNumber,
            numberOfPeople,
            date,
            startTime,
            duration
        }),
    })
    .then(res => res.json())
    .then(data => {
        if (data.success) {
            // Update localStorage with the latest phone number
            localStorage.setItem('phoneNumber', phoneNumber);

            // Confirm booking
            document.getElementById('booking-section').classList.add('hidden');
            document.getElementById('confirmation-section').classList.remove('hidden');
            document.getElementById('confirmation-section').classList.add('visible');

            // Close the booking modal if it's still open
            if (window.bootstrap && window.bootstrap.Modal) {
                const slotModal = window.bootstrap.Modal.getInstance(slotModalElement);
                if (slotModal) {
                    slotModal.hide();
                }
            }

            // Display booking details
            document.getElementById('confirmation-section').innerHTML = `
                <h3 class="mb-4">Booking Confirmed!</h3>
                <p>Thank you, <strong>${userName}</strong>, for your booking.</p>
                <p>Booking Details:</p>
                <ul class="list-unstyled">
                    <li>Date: ${date}</li>
                    <li>Start Time: ${startTime}</li>
                    <li>Duration: ${duration} hour(s)</li>
                    <li>Number of People: ${numberOfPeople}</li>
                </ul>
                <button class="btn btn-primary mt-3" onclick="promptAnotherBooking()">
                    <i class="fas fa-calendar-check me-2"></i>Book Another Slot
                </button>
            `;
            // Optionally, log out the user automatically
            // logoutUser(); // Implement this function if desired
        } else {
            // Re-enable confirm button and 'Back' and 'X' buttons
            confirmButton.disabled = false;
            confirmButton.innerHTML = originalButtonText;

            if (backButton) {
                backButton.disabled = false;
            }
            if (closeButton) {
                closeButton.classList.remove('disabled');
            }
            if (spinnerOverlay) {
                spinnerOverlay.classList.add('hidden');
            }

            alert(data.message || 'Failed to book the slot.');
        }
    })
    .catch(err => {
        // Re-enable confirm button and 'Back' and 'X' buttons
        confirmButton.disabled = false;
        confirmButton.innerHTML = originalButtonText;

        if (backButton) {
            backButton.disabled = false;
        }
        if (closeButton) {
            closeButton.classList.remove('disabled');
        }
        if (spinnerOverlay) {
            spinnerOverlay.classList.add('hidden');
        }

        console.error('Error booking slot:', err);
        alert('An error occurred while booking. Please try again.');
    });
});

// Function to prompt the user for another booking
function promptAnotherBooking() {
    if (confirm('Would you like to make another booking?')) {
        // Reset to booking section
        document.getElementById('confirmation-section').classList.add('hidden');
        document.getElementById('booking-section').classList.remove('hidden');
        document.getElementById('booking-section').classList.add('visible');
        initializeBooking();
    } else {
        // Log out the user and redirect to login
        logoutUser();
    }
}

// Function to log out the user
function logoutUser() {
    localStorage.clear();
    // Redirect to login section
    document.getElementById('booking-section').classList.add('hidden');
    document.getElementById('confirmation-section').classList.add('hidden');
    document.getElementById('login-section').classList.remove('hidden');
    document.getElementById('login-section').classList.add('visible');
    // Hide logout button
    document.getElementById('logout-button').style.display = 'none';
}

// Logout button functionality
document.getElementById('logout-button').addEventListener('click', () => {
    logoutUser();
});

// Utility function to reload the page
function reloadPage() {
    window.location.reload();
}

// Initialize Bootstrap tooltips
function initializeTooltips() {
    if (window.bootstrap && window.bootstrap.Tooltip) {
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new window.bootstrap.Tooltip(tooltipTriggerEl);
        });
    } else {
        console.error('Bootstrap Tooltip is not available.');
    }
}

// Handle Number of People Button Clicks
document.querySelectorAll('.num-people-button').forEach(button => {
    button.addEventListener('click', () => {
        // Remove active class from all buttons
        document.querySelectorAll('.num-people-button').forEach(btn => btn.classList.remove('active'));
        // Add active class to the clicked button
        button.classList.add('active');
        // Set the hidden input value
        document.getElementById('number-of-people').value = button.getAttribute('data-value');

        // Update border colors based on selection
        updateNumberOfPeopleBorders();

        validateForm();
    });
});

// Update border colors for Number of People buttons
function updateNumberOfPeopleBorders() {
    const selectedValue = document.getElementById('number-of-people').value;
    const buttons = document.querySelectorAll('.num-people-button');

    if (selectedValue) {
        // If a number is selected, add green border and remove red
        buttons.forEach(btn => {
            btn.classList.remove('red-border');
            btn.classList.add('green-border');
        });
        // Hide error message
        document.getElementById('people-error').style.display = 'none';
    } else {
        // If no selection, add red border and remove green
        buttons.forEach(btn => {
            btn.classList.remove('green-border');
            btn.classList.add('red-border');
        });
        // Show error message
        document.getElementById('people-error').style.display = 'block';
    }
}

// Validate Form Fields to Enable/Disable Confirm Booking Button
function validateForm() {
    const startTime = document.getElementById('selected-start-time').textContent.trim();
    const duration = document.getElementById('duration-select').value;
    const endTime = document.getElementById('end-time-display').textContent.trim();
    const phoneNumber = document.getElementById('phone-number').value.trim();
    const numberOfPeople = document.getElementById('number-of-people').value;

    let isValid = true;

    // Validate Start Time
    if (startTime === '--:--') {
        isValid = false;
    }

    // Validate Duration
    if (duration === '') {
        document.getElementById('duration-error').style.display = 'block';
        isValid = false;
    } else {
        document.getElementById('duration-error').style.display = 'none';
    }

    // Validate End Time
    if (endTime === '--:--') {
        isValid = false;
    }

    // Validate Phone Number
    const phoneRegex = /^\+?[0-9\s\-()]{7,15}$/; // Allows +, numbers, spaces, dashes, parentheses
    if (phoneNumber === '') {
        document.getElementById('phone-error').textContent = 'Please enter your phone number.';
        document.getElementById('phone-error').style.display = 'block';
        isValid = false;
    } else if (!phoneRegex.test(phoneNumber)) {
        document.getElementById('phone-error').textContent = 'Please enter a valid phone number.';
        document.getElementById('phone-error').style.display = 'block';
        isValid = false;
    } else {
        document.getElementById('phone-error').style.display = 'none';
    }

    // Validate Number of People
    if (numberOfPeople === '') {
        document.getElementById('people-error').style.display = 'block';
        isValid = false;
    } else {
        document.getElementById('people-error').style.display = 'none';
    }

    const confirmButton = document.getElementById('submit-booking-button');
    if (isValid) {
        confirmButton.disabled = false;
    } else {
        confirmButton.disabled = true;
    }
}




==== public/index.html ====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LENGOLF Booking System</title>

    <!-- Bootstrap CSS -->
    <link 
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.3/dist/css/bootstrap.min.css" 
        rel="stylesheet" 
        crossorigin="anonymous"
    >

    <!-- Font Awesome CSS for Icons (Version 6.6) -->
    <link 
        rel="stylesheet" 
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" 
        crossorigin="anonymous"
    />
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/styles.css">
    
    <!-- Google Sign-In JavaScript library -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    
    <!-- Luxon JS Library -->
    <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">LENGOLF Booking</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" 
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <button class="btn btn-secondary ms-auto" id="logout-button" style="display: none;">
                    <i class="fas fa-sign-out-alt me-2"></i>Logout
                </button>
            </div>
        </div>
    </nav>

    <!-- Main Container -->
    <div class="container mt-5 pt-5">
        <!-- Login Section -->
        <div id="login-section" class="text-center">
            <h2 class="mb-4">Welcome to LENGOLF!</h2>
            <p>Please sign in with Google to start booking your slot.</p>

            <!-- Google Sign-In Button -->
            <div id="g_id_onload"
                data-client_id="459419604461-40b814vc4m04mq4qp8a30luiocs8961d.apps.googleusercontent.com"
                data-callback="handleCredentialResponse"
                data-auto_prompt="false">
            </div>

            <div class="g_id_signin mt-3"
                data-type="standard"
                data-size="large"
                data-theme="outline"
                data-text="sign_in_with"
                data-shape="rectangular"
                data-logo_alignment="left">
            </div>
        </div>

        <!-- Booking Section -->
        <div id="booking-section" class="mt-5 hidden">
            <h2 class="text-center mb-4">Step 1: Select a Date</h2>
            <p class="text-center">Choose a date and we will show you the available slots.</p>
            <div class="d-flex justify-content-between align-items-center mb-4 date-picker-container">
                <h3 class="mb-0">Available Slots for <span id="selected-date"></span></h3>
                <input type="date" id="booking-date" class="form-control w-auto" required />
            </div>
            <div id="loading-spinner" class="text-center my-5" style="display: none;">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-3">Fetching available slots...</p>
            </div>
            <div id="available-slots" class="row">
                <!-- Available slots will be displayed here as Bootstrap columns -->
            </div>
        </div>

        <!-- Confirmation Section -->
        <div id="confirmation-section" class="mt-5 text-center hidden">
            <!-- Booking confirmation content will be injected here dynamically -->
        </div>
    </div>

    <!-- Slot Selection Modal -->
    <div class="modal fade" id="slotModal" tabindex="-1" aria-labelledby="slotModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-dialog-centered modal-fullscreen-sm-down">
            <div class="modal-content position-relative">
                <!-- Spinner Overlay -->
                <div class="modal-spinner-overlay hidden">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Booking in progress...</span>
                    </div>
                </div>
                <div class="modal-header">
                    <h5 id="slotModalLabel" class="modal-title">Complete Your Booking</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <h6 class="mb-4">Selected Start Time: <strong id="selected-start-time"></strong></h6>
                    <!-- Duration Selection -->
                    <div class="mb-4">
                        <label for="duration-select" class="form-label">Select Duration (hours):</label>
                        <select id="duration-select" class="form-select" required>
                            <!-- Options will be dynamically loaded here -->
                        </select>
                        <div id="duration-error" class="text-danger mt-2" style="display: none;">
                            Please select a duration.
                        </div>
                    </div>
                    <!-- Display End Time -->
                    <div class="mb-4">
                        <label class="form-label">End Time:</label>
                        <p id="end-time-display" class="fs-5"><strong>--:--</strong></p>
                    </div>
                    <!-- Phone Number Input -->
                    <div class="mb-4">
                        <label for="phone-number" class="form-label">Phone Number:</label>
                        <input type="tel" id="phone-number" class="form-control" placeholder="Enter your phone number" required>
                        <small id="phone-prefilled-indicator" class="form-text text-muted" style="display: none;">
                            Prefilled from your account. You can change it if needed.
                        </small>
                        <div id="phone-error" class="text-danger mt-2" style="display: none;">
                            Please enter your phone number.
                        </div>
                    </div>
                    <!-- Number of People Selection -->
                    <div class="mb-4">
                        <label class="form-label d-block">Number of People:</label>
                        <div id="number-of-people-buttons" class="btn-group" role="group" aria-label="Number of People">
                            <button type="button" class="btn btn-outline-secondary num-people-button" data-value="1">1</button>
                            <button type="button" class="btn btn-outline-secondary num-people-button" data-value="2">2</button>
                            <button type="button" class="btn btn-outline-secondary num-people-button" data-value="3">3</button>
                            <button type="button" class="btn btn-outline-secondary num-people-button" data-value="4">4</button>
                            <button type="button" class="btn btn-outline-secondary num-people-button" data-value="5">5</button>
                        </div>
                        <input type="hidden" id="number-of-people" value="" required>
                        <div id="people-error" class="text-danger mt-2" style="display: none;">
                            Please select the number of people.
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                        <i class="fas fa-arrow-left me-2"></i>Back
                    </button>
                    <button type="button" class="btn btn-primary" id="submit-booking-button" disabled>
                        <i class="fas fa-check-circle me-2"></i>Confirm Booking
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script 
        src="https://cdn.jsdelivr.net/npm/bootstrap@5.3/dist/js/bootstrap.bundle.min.js" 
        crossorigin="anonymous">
    </script>

    <!-- Custom JavaScript -->
    <script src="/js/main.js" defer></script>
</body>
</html>




==== routes/api.js ====

// routes/api.js

const express = require('express');
const router = express.Router();
const redisHelper = require('../utils/redisHelper'); // Corrected path
const helpers = require('../utils/helpers'); // Import helpers if needed
const logger = require('../utils/logger'); // Optional: For structured logging
const customerController = require('../controllers/customerController'); // Import customer controller
const { OAuth2Client } = require('google-auth-library');

const CLIENT_ID = '459419604461-40b814vc4m04mq4qp8a30luiocs8961d.apps.googleusercontent.com'; // Replace with your actual client ID
const client = new OAuth2Client(CLIENT_ID);

// New Login Route
router.post('/login', async (req, res) => {
    const { token } = req.body;

    if (!token) {
        return res.status(400).json({ success: false, message: 'Token is required.' });
    }

    try {
        const ticket = await client.verifyIdToken({
            idToken: token,
            audience: CLIENT_ID,
        });

        const payload = ticket.getPayload();
        const userId = payload['sub'];
        const email = payload['email'];
        const name = payload['name'];

        // Fetch customer data from Google Sheets
        const customerData = await customerController.getCustomerDataById(userId);
        const phoneNumber = customerData ? customerData.phoneNumber : '';

        // Optionally, save or update user in your database
        // For example:
        // await userController.createOrUpdateUser({ userId, email, name });

        return res.status(200).json({ success: true, userId, email, name, phoneNumber });
    } catch (error) {
        logger.error('Error verifying Google token:', error);
        return res.status(401).json({ success: false, message: 'Invalid token.' });
    }
});

// Route to get available start times with max durations
router.get('/available-slots', async (req, res) => {
    const date = req.query.date; // Expected format: 'YYYY-MM-DD'

    if (!date) {
        return res.status(400).json({ success: false, message: 'Date parameter is required.' });
    }

    try {
        // Attempt to fetch availability from Redis
        const cachedData = await redisHelper.client.get(`available_slots_${date}`); // Updated cache key

        if (cachedData) {
            const availableSlots = JSON.parse(cachedData);
            return res.status(200).json({ success: true, availableSlots });
        } else {
            // If not cached, fetch from backend, cache it, and respond
            const availableSlots = await redisHelper.refreshAvailableStartTimesCache(date);
            return res.status(200).json({ success: true, availableSlots });
        }
    } catch (error) {
        logger.error('Error fetching available start times:', error);
        return res.status(500).json({ success: false, message: 'Internal Server Error.' });
    }
});

// Route to book a slot
router.post('/book-slot', async (req, res) => {
    const { userId, userName, email, phoneNumber, numberOfPeople, date, startTime, duration } = req.body;

    // Basic validation
    if (!userId || !userName || !email || !phoneNumber || !numberOfPeople || !date || !startTime || !duration) {
        return res.status(400).json({ success: false, message: 'Missing required booking parameters.' });
    }

    if (duration < 1 || duration > 5) {
        return res.status(400).json({ success: false, message: 'Duration must be between 1 and 5 hours.' });
    }

    try {
        // Create the booking and assign a bay
        const booking = await helpers.createBooking(date, startTime, duration, userId, userName, phoneNumber, numberOfPeople, email);

        if (!booking) {
            return res.status(409).json({ success: false, message: 'No available bays for the selected time and duration.' });
        }

        // Save or update customer data with latest phone number and email
        await customerController.saveOrUpdateCustomerData({ userId, name: userName, email, phoneNumber });

        // Respond with booking details
        return res.status(200).json({
            success: true,
            message: `Booking confirmed for ${booking.bay} from ${booking.startTime} for ${booking.duration} hour(s).`,
            assignedBay: booking.bay,
            startTime: booking.startTime,
            duration: booking.duration,
        });
    } catch (error) {
        logger.error('Error processing booking:', error);
        return res.status(500).json({ success: false, message: 'Internal Server Error.' });
    }
});

// Route to get customer data by userId (optional, if needed)
router.get('/get-customer-data', async (req, res) => {
    const userId = req.query.userId;

    if (!userId) {
        return res.status(400).json({ success: false, message: 'userId parameter is required.' });
    }

    try {
        const customerData = await customerController.getCustomerDataById(userId);
        return res.status(200).json({ success: true, customerData });
    } catch (error) {
        logger.error('Error fetching customer data:', error);
        return res.status(500).json({ success: false, message: 'Internal Server Error.' });
    }
});

module.exports = router;




==== utils/helpers.js ====

// utils/helpers.js

const { CALENDARS, googleAuth, SPREADSHEET_ID } = require('../config/googleApiConfig');
const { google } = require('googleapis');
const { DateTime, Interval } = require('luxon'); // Ensure Luxon is installed: npm install luxon
const lineNotify = require('./lineNotify'); // Assuming you want to send LINE notifications
const redisHelper = require('./redisHelper'); // To interact with Redis if needed
const logger = require('./logger'); // Ensure logger is imported

// Initialize Google Auth
const auth = new google.auth.GoogleAuth({
    credentials: googleAuth.credentials,
    scopes: googleAuth.scopes,
});

// Google Calendar instance
const calendar = google.calendar({ version: 'v3', auth });

// Google Sheets instance
const sheets = google.sheets({ version: 'v4', auth });

/**
 * Fetch busy times for all bays on a specific date.
 * @param {string} dateStr - Date in 'YYYY-MM-DD' format.
 * @returns {Object} - Mapping of bay names to their busy intervals.
 */
async function fetchAllBaysBusyTimes(dateStr) {
    const busyTimes = {};

    // Iterate over each bay
    for (const bayName in CALENDARS) {
        const calendarId = CALENDARS[bayName];
        if (!calendarId) {
            continue;
        }

        // Define time range for the day in Asia/Bangkok timezone
        const startOfDay = DateTime.fromISO(`${dateStr}T00:00:00`, { zone: 'Asia/Bangkok' }).toUTC().toISO();
        const endOfDay = DateTime.fromISO(`${dateStr}T23:59:59`, { zone: 'Asia/Bangkok' }).toUTC().toISO();

        const freebusyRequest = {
            requestBody: {
                timeMin: startOfDay,
                timeMax: endOfDay,
                items: [{ id: calendarId }],
            },
        };

        try {
            const freebusy = await calendar.freebusy.query(freebusyRequest);
            const calendarsBusy = freebusy.data.calendars;

            if (calendarsBusy[calendarId]) {
                busyTimes[bayName] = calendarsBusy[calendarId].busy.map(event => {
                    return {
                        start: DateTime.fromISO(event.start).setZone('Asia/Bangkok'),
                        end: DateTime.fromISO(event.end).setZone('Asia/Bangkok'),
                    };
                });
            } else {
                busyTimes[bayName] = [];
            }
        } catch (error) {
            logger.error(`Error fetching free/busy for ${bayName}:`, error);
            busyTimes[bayName] = []; // Assume no busy times on error
        }
    }

    return busyTimes;
}

/**
 * Determine available start times with maximum durations.
 * Excludes past slots if the date is today.
 * @param {string} dateStr - Date in 'YYYY-MM-DD' format.
 * @returns {Array} - List of available start times with max durations.
 */
async function getAvailableStartTimes(dateStr) {
    const openingHour = 10; // 10:00 AM
    const closingHour = 22; // 10:00 PM
    const maxDuration = 5;  // Maximum 5 hours

    const busyTimes = await fetchAllBaysBusyTimes(dateStr);

    // Initialize availability map for each bay
    const availabilityMap = {};

    for (const bayName in CALENDARS) {
        availabilityMap[bayName] = [];
        for (let hour = openingHour; hour < closingHour; hour++) {
            availabilityMap[bayName][hour] = true; // Assume available
        }

        // Mark busy times
        busyTimes[bayName].forEach(event => {
            const startHour = event.start.hour;
            const endHour = event.end.hour;
            for (let hour = startHour; hour < endHour; hour++) {
                if (hour >= openingHour && hour < closingHour) {
                    availabilityMap[bayName][hour] = false;
                }
            }
        });
    }

    // Determine if the selected date is today
    const now = DateTime.now().setZone('Asia/Bangkok');
    const isToday = now.toISODate() === dateStr;

    // Determine available start times with max durations
    const availableSlots = [];

    for (let startHour = openingHour; startHour < closingHour; startHour++) {
        // If the date is today, exclude slots that have already started
        if (isToday && startHour < now.hour) {
            continue;
        }

        let slotMaxDuration = 0;

        for (let duration = 1; duration <= maxDuration; duration++) {
            const endHour = startHour + duration;
            if (endHour > closingHour) break; // Exceeds closing time

            let isAvailable = false;

            // Check if any bay is available for the entire duration
            for (const bayName in CALENDARS) {
                let bayAvailable = true;
                for (let hour = startHour; hour < endHour; hour++) {
                    if (!availabilityMap[bayName][hour]) {
                        bayAvailable = false;
                        break;
                    }
                }
                if (bayAvailable) {
                    isAvailable = true;
                    break;
                }
            }

            if (isAvailable) {
                slotMaxDuration = duration;
            } else {
                break; // No longer durations available
            }
        }

        if (slotMaxDuration > 0) {
            availableSlots.push({
                startTime: `${startHour.toString().padStart(2, '0')}:00`,
                maxDuration: slotMaxDuration,
            });
        }
    }

    return availableSlots;
}

/**
 * Create and insert a booking into Google Calendar with formatted summary.
 * @param {string} dateStr - Date in 'YYYY-MM-DD' format.
 * @param {string} startTime - Start time in 'HH:mm' format.
 * @param {number} duration - Duration in hours.
 * @param {string} userId - User ID.
 * @param {string} userName - User's name.
 * @param {string} phoneNumber - User's phone number.
 * @param {number} numberOfPeople - Number of people.
 * @param {string} email - User's email.
 * @returns {Object|null} - Assigned bay and booking details.
 */
async function createBooking(dateStr, startTime, duration, userId, userName, phoneNumber, numberOfPeople, email) {
    // Assign a bay using assignBay function
    const assignedBay = await assignBay(dateStr, startTime, duration);

    if (!assignedBay) {
        return null; // No available bay
    }

    // Create the booking by adding an event to the assigned bay's Google Calendar
    const calendarId = CALENDARS[assignedBay.bay];

    const eventStart = DateTime.fromISO(`${dateStr}T${startTime}`, { zone: 'Asia/Bangkok' }).toUTC();
    const eventEnd = eventStart.plus({ hours: duration });

    const event = {
        summary: `${userName} (${phoneNumber}) (${numberOfPeople}) - ${assignedBay.bay}`,
        description: `Name: ${userName}\nEmail: ${email}\nPhone: ${phoneNumber}\nPeople: ${numberOfPeople}`,
        start: {
            dateTime: eventStart.toISO(),
            timeZone: 'UTC',
        },
        end: {
            dateTime: eventEnd.toISO(),
            timeZone: 'UTC',
        },
    };

    try {
        await calendar.events.insert({
            calendarId: calendarId,
            resource: event,
        });

        // Send a LINE notification with the user's name, email, and phone number
        const bookingDetails = {
            customerName: userName, // Use actual name
            email: email, // Include email
            phoneNumber: phoneNumber, // Include phone number
            bookingDate: dateStr,
            bookingStartTime: startTime,
            bookingEndTime: eventEnd.toFormat('HH:mm'),
            bayNumber: assignedBay.bay,
        };

        await lineNotify.sendBookingNotificationToLINE(bookingDetails);

        return {
            bay: assignedBay.bay,
            startTime: startTime,
            duration: duration,
        };
    } catch (error) {
        logger.error('Error creating booking:', error);
        return null;
    }
}

/**
 * Assign a bay based on availability.
 * @param {string} dateStr - Date in 'YYYY-MM-DD' format.
 * @param {string} startTime - Start time in 'HH:mm' format.
 * @param {number} duration - Duration in hours.
 * @returns {Object|null} - Assigned bay or null if none available.
 */
async function assignBay(dateStr, startTime, duration) {
    const busyTimes = await fetchAllBaysBusyTimes(dateStr);

    const bookingStart = DateTime.fromISO(`${dateStr}T${startTime}`, { zone: 'Asia/Bangkok' }).toUTC();
    const bookingEnd = bookingStart.plus({ hours: duration });

    for (const bayName in CALENDARS) {
        const isAvailable = busyTimes[bayName].every(event => {
            const eventStart = event.start;
            const eventEnd = event.end;
            return bookingEnd <= eventStart || bookingStart >= eventEnd;
        });

        if (isAvailable) {
            // Assign this bay
            return {
                bay: bayName,
                interval: {
                    start: bookingStart.toISO(),
                    end: bookingEnd.toISO(),
                },
            };
        }
    }

    // No available bay found
    return null;
}

/**
 * Fetch customer data from Google Sheets.
 * @param {string} userId - User ID to fetch data for.
 * @returns {Object|null} - Customer data or null if not found.
 */
async function getCustomerData(userId) {
    try {
        const response = await sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID,
            range: 'Customers!A1:D', // Start from the first row including headers
        });

        const rows = response.data.values;
        if (!rows || rows.length === 0) {
            logger.warn('No data found in Google Sheets.');
            return null;
        }

        // Skip the header row if present
        const startRow = rows[0][0] === 'UserID' ? 1 : 0;
        const customerRows = rows.slice(startRow);

        // Find the row with matching userId
        const customerRow = customerRows.find(row => row[0] === userId);
        if (customerRow) {
            return {
                userId: customerRow[0],
                name: customerRow[1],
                email: customerRow[2], // Column C (0-based index 2)
                phoneNumber: customerRow[3], // Column D (0-based index 3)
            };
        } else {
            logger.warn(`No customer data found for userId: ${userId}`);
            return null;
        }
    } catch (error) {
        logger.error('Error fetching customer data from Google Sheets:', error);
        return null;
    }
}

/**
 * Save or update customer data in Google Sheets.
 * @param {Object} customerData - Customer data to save.
 */
async function saveCustomerData(customerData) {
    const { userId, name, email, phoneNumber } = customerData;

    try {
        // Fetch existing data
        const response = await sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID,
            range: 'Customers!A1:D', // Start from the first row including headers
        });

        const rows = response.data.values || [];
        // Determine if headers are present
        const hasHeaders = rows[0][0] === 'UserID';
        const startRow = hasHeaders ? 1 : 0;
        const customerRows = rows.slice(startRow);
        const rowIndex = customerRows.findIndex(row => row[0] === userId);

        if (rowIndex !== -1) {
            // Update existing row
            await sheets.spreadsheets.values.update({
                spreadsheetId: SPREADSHEET_ID,
                range: `Customers!A${rowIndex + startRow + 1}:D${rowIndex + startRow + 1}`,
                valueInputOption: 'RAW',
                resource: {
                    values: [[userId, name, email, phoneNumber]], // Email in column C
                },
            });
            logger.info(`Updated customer data for userId: ${userId}`);
        } else {
            // Append new row
            await sheets.spreadsheets.values.append({
                spreadsheetId: SPREADSHEET_ID,
                range: 'Customers!A:D', // Ensure data includes columns A to D
                valueInputOption: 'RAW',
                insertDataOption: 'INSERT_ROWS',
                resource: {
                    values: [[userId, name, email, phoneNumber]], // Email in column C
                },
            });
            logger.info(`Added new customer data for userId: ${userId}`);
        }
    } catch (error) {
        logger.error('Error saving customer data to Google Sheets:', error);
    }
}

/**
 * Fetch availability of time slots from Google Calendar.
 * @param {string} dateStr - Date in 'YYYY-MM-DD' format.
 * @returns {Array} - Available slots with startTime and maxDuration.
 */
async function findAvailableSlotsFromGoogle(dateStr) {
    return await getAvailableStartTimes(dateStr);
}

module.exports = {
    getAvailableStartTimes,
    assignBay,
    createBooking, // Ensure createBooking is exported
    getCustomerData, // Export to be used in customerController
    saveCustomerData, // Export to be used in customerController
    findAvailableSlotsFromGoogle, // Export for bookingController
};



==== utils/lineNotify.js ====

// utils/lineNotify.js

// utils/lineNotify.js

const { LINE_NOTIFY_TOKEN } = require('../config/googleApiConfig');

/**
 * Sends a booking notification to LINE Notify.
 */
exports.sendBookingNotificationToLINE = async (bookingDetails) => {
    const lineMessage = createLineMessageFromBookingDetails(bookingDetails);

    if (lineMessage) {
        console.log("Sending LINE Notify message: " + lineMessage);
        await sendLineNotify(lineMessage);
    } else {
        console.log("Booking details are missing or incorrect.");
    }
};

/**
 * Creates a formatted LINE message from booking details.
 */
function createLineMessageFromBookingDetails(bookingDetails) {
    const { customerName, email, phoneNumber, bookingDate, bookingStartTime, bookingEndTime, bayNumber } = bookingDetails;

    if (!customerName || !email || !phoneNumber || !bookingDate || !bookingStartTime || !bookingEndTime || !bayNumber) {
        return null; // Return null if any important detail is missing
    }

    return `Booking Notification
Name: ${customerName}
Email: ${email}
Phone: ${phoneNumber}
Date: ${bookingDate}
Time: ${bookingStartTime} - ${bookingEndTime}
Bay: ${bayNumber}

Please prepare accordingly.`;
}

/**
 * Sends a message to LINE Notify API.
 */
async function sendLineNotify(message) {
    const options = {
        method: "POST",
        body: new URLSearchParams({ message: message }),
        headers: {
            "Authorization": `Bearer ${LINE_NOTIFY_TOKEN}`,
            "Content-Type": "application/x-www-form-urlencoded"
        }
    };

    try {
        const response = await fetch("https://notify-api.line.me/api/notify", options);
        const responseText = await response.text();
        console.log("LINE response: " + responseText);
    } catch (error) {
        console.log("Error sending LINE notification: " + error.message);
    }
}




==== utils/logger.js ====

// utils/logger.js

const { createLogger, format, transports } = require('winston');

// Define custom log format
const customFormat = format.combine(
    format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    format.errors({ stack: true }), // Capture stack trace
    format.splat(),
    format.printf(({ timestamp, level, message, stack }) => {
        return stack
            ? `${timestamp} [${level}]: ${message} - ${stack}`
            : `${timestamp} [${level}]: ${message}`;
    })
);

// Create logger instance
const logger = createLogger({
    level: 'info', // Default log level
    format: customFormat,
    transports: [
        // Write all logs with level `error` and below to `error.log`
        new transports.File({ filename: 'error.log', level: 'error' }),
        // Write all logs with level `info` and below to `combined.log`
        new transports.File({ filename: 'combined.log' }),
    ],
});

// If not in production, also log to the console with the same format
if (process.env.NODE_ENV !== 'production') {
    logger.add(new transports.Console({
        format: customFormat
    }));
}

module.exports = logger;




==== utils/scheduler.js ====

// utils/scheduler.js

const cron = require('node-cron');
const { refreshAvailableStartTimesCache } = require('./redisHelper');
const { DateTime } = require('luxon'); // Ensure Luxon is installed: npm install luxon
const logger = require('./logger'); // Optional: For structured logging

/**
 * Function to fetch and cache availability for the next 5 days.
 */
async function fetchAndCacheAvailability() {
    try {
        const today = DateTime.local().startOf('day'); // Current day at 00:00
        const dates = [];

        for (let i = 0; i < 5; i++) { // Next 5 days including today
            const date = today.plus({ days: i }).toISODate(); // 'YYYY-MM-DD'
            dates.push(date);
        }

        // Fetch availability for all dates in parallel
        await Promise.all(dates.map(date => refreshAvailableStartTimesCache(date)));

        logger.info('Availability data refreshed and cached successfully for the next 5 days.');
    } catch (error) {
        logger.error('Error fetching and caching availability:', error);
    }
}

// Schedule the task to run every 2 minutes
cron.schedule('*/2 * * * *', () => {
    logger.info('Running scheduled task: fetchAndCacheAvailability');
    fetchAndCacheAvailability();
});

// Optionally, run the task immediately on server start
fetchAndCacheAvailability();

module.exports = {};




==== utils/redisHelper.js ====

// utils/redisHelper.js

const client = require('../config/redisConfig'); // Corrected path to redisConfig
const { getAvailableStartTimes } = require('./helpers');
const logger = require('./logger'); // Ensure logger is correctly imported

/**
 * Refresh available start times for a given date and cache them.
 * @param {string} dateStr - Date in 'YYYY-MM-DD' format.
 * @returns {Array} - Array of available start times with max durations.
 */
async function refreshAvailableStartTimesCache(dateStr) {
    try {
        const availableSlots = await getAvailableStartTimes(dateStr);
        // Use consistent cache key
        await client.setEx(`available_slots_${dateStr}`, 600, JSON.stringify(availableSlots));
        logger.info(`Cached availability for ${dateStr}`);
        return availableSlots;
    } catch (error) {
        logger.error('Error refreshing available start times cache:', error);
        throw error;
    }
}

module.exports = {
    refreshAvailableStartTimesCache,
    client, // Export the Redis client if needed elsewhere
};




==== index.js ====

// index.js

require('dotenv').config();
const express = require('express');
const cors = require('cors');
const path = require('path');
const apiRouter = require('./routes/api'); // Import your API router
const redisHelper = require('./utils/redisHelper');
const logger = require('./utils/logger'); // Ensure you have a logger utility

const app = express();
const PORT = process.env.PORT || 3000;

// CORS setup
app.use(cors());

// JSON parsing middleware
app.use(express.json());

// Middleware to set Cross-Origin-Opener-Policy
app.use((req, res, next) => {
    res.setHeader('Cross-Origin-Opener-Policy', 'same-origin-allow-popups');
    next();
});

// Serve static files from 'public' directory
app.use(express.static(path.join(__dirname, 'public')));

// Use the API router for all /api routes
app.use('/api', apiRouter);

// Serve static HTML file directly
app.get('/', (req, res) => {
    const indexPath = path.join(__dirname, 'public', 'index.html');
    res.sendFile(indexPath);
});

// Start the server
app.listen(PORT, () => {
    logger.info(`Server is running on port ${PORT}`);
});

// Start the Redis cache refresh job
// Assuming you want to refresh availability for a specific date on server start
// If not, you might need to implement a scheduler (e.g., using node-cron)

const today = new Date().toISOString().split('T')[0];
redisHelper.refreshAvailableStartTimesCache(today)
    .then(() => {
        logger.info(`Initial cache refresh for ${today} completed.`);
    })
    .catch((err) => {
        logger.error('Error during initial cache refresh:', err);
    });


